
---
<br/>

The Legendary Labs Project includes additional **Access Control** mechinisms built into the contracts. This will allow the project to have a more robust system when it comes to authorizing who should be allowed to call what in the contracts.

**Access Control** is worked into the [**LegendaryLaboratory**](./LegendsLaboratory) via inheritance of OpenZeppelin's `AccessControlEnumerable.sol`


<details>
<summary>OpenZeppelin's Comments From AccessControl.sol</summary>
<div>
  <p>Contract module that allows children to implement role-based access
  control mechanisms. This is a lightweight version that doesn't allow enumerating role
  members except through off-chain means by accessing the contract event logs. Some
  applications may benefit from on-chain enumerability, for those cases see `AccessControlEnumerable`. 
  
  <br/><br/>

  Roles are referred to by their `bytes32` identifier. These should be exposed
 in the external API and be unique. The best way to achieve this is by
 using `public constant` hash digests:

 ```
 bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 ```

 Roles can be used to represent a set of permissions. To restrict access to a
 function call, use {hasRole}:

 ```
 function foo() public {
     require(hasRole(MY_ROLE, msg.sender));
     ...
 }
 ```

 Roles can be granted and revoked dynamically via the {grantRole} and
 {revokeRole} functions. Each role has an associated admin role, and only
 accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 that only accounts with this role will be able to grant or revoke other
 roles. More complex role relationships can be created by using
 {_setRoleAdmin}.

 WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 grant and revoke this role. Extra precautions should be taken to secure
 accounts that have been granted it.
  
  </p>

</div>
</details>

<br/>

## Basics Of Access Control
---

modifier
 3 roles
 how roles work


<br/>

## Granting And Revoking Access 
---

grant 
revoke
renounce


<br/>

## Querying Access Control
---



### header

``` sol ="Title | vis | mod" 

```

:::note

message

:::




## Renounce Lab Adminship
---


Resets the [`_ReJuNeededPerSlot`](docs/LegendsRejuvenation#setReJuNeededPerSlot) to restore a *blending instance*. Only callable by *the* `LAB_ADMIN`.


``` sol title="transferLaboratoryAdmin(address newAdmin)` (public)

There Can Only Be One..



Only callable by *the* `LAB_ADMIN`. Function calls *this* contract to revoke the current `LAB_ADMIN`'s
authorization and grant authorization to the incoming admin in the same block.

:::note

Many of the functions the `LAB_ADMIN` has authorization to call should only be called rarely, if ever.
In order to prevent more than (1) `LAB_ADMIN` existing at one time, *this* contract is given sole ability
to revoke and grant `LAB_ADMIN` access. This should be the only way a `LAB_ADMIN` role can be granted.

:::

:::warning

By calling this function you will give up you privileges as `Lab_ADMIN`. If the `newAdmin`is supplied the *0 address*,
a burn address, or any otherwise inaccessible address, full control over the Legendary Labs project would be renounced.

:::





<br/>

## Who Can Call What
---