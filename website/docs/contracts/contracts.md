---
sidebar_position: 1
title: Contracts Intro
---

# Smart Contracts
---

## Communicating With Contracts

Interacting with smart contract can be a pretty straight forward process. Most calls to a smart contract are structured similarly, whether they are reading from or writing to the contracts.

One of the more important aspects of talking to smart contract, is knowing which functions are allowed to be called. Most of this is determined by the function visibility.

:::note Visibilities:

  * Public &rarr; Any address can call or modify
  * External &rarr; Any address, except the contract itself, can cal. The `this` keyword can be used allowing a contract to call it's own *external* functions, however, this pertains more to contract development than interaction.
  * Internal &rarr; Only the contract itself, and any contracts inheriting the said contract, can call.
  * Private &rarr; Only the contract itself can call.

:::

:::tip Note

All internal/private functions, in the **LegendaryLabs** contracts are indicated with a `_` prefixing the function name.

:::
  




<br/>


### Front End
---

In order to talk to the **LegendaryLabs** contract *ethers* will need to be imported.

``` js title="import ethers.js"
import { ethers } from "ethers";
```


:::info Todo

## Create Module For ethers Logic:

I will create a module to fit into our front end in order to simplify and abstract away some of the more *ethers* specific logic.

:::

#### Currently:

The smart contracts addresses will need to be imported from the current config file. 

``` js title="import contract addresses"
import {
  legendsLaboratory,
  legendsNFT,
  legendsToken,
  legendRejuvenation,
  legendsMarketplace,
  legendsMatchingBoard,
  laboratoryGovernor
} from 'contract_config/contract-config'
```

:::tip Note

New contract addresses can be generated by running `yarn hh:load`.

:::

The ABIs for the smart contracts will need importing as well. These come from the `artifacts/` directory.

``` js title="import contract ABIs"
import LegendsLaboratory from '../../artifacts/contracts/lab/LegendsLaboratory.sol/LegendsLaboratory.json'
import LegendsNFT from '../../artifacts/contracts/legend/LegendsNFT.sol/LegendsNFT.json'
import LegendToken from '../../artifacts/contracts/token/LegendToken.sol/LegendToken.json'
import LegendRejuvenation from '../../artifacts/contracts/lab/LegendRejuvenation.sol/LegendRejuvenation.json'
import LegendsMarketplace from '../../artifacts/contracts/marketplace/LegendsMarketplace.sol/LegendsMarketplace.json'
import LegendsMatchingBoard from '../../artifacts/contracts/matching/LegendsMatchingBoard.sol/LegendsMatchingBoard.json'
import LaboratoryGovernor from '../../artifacts/contracts/token/LaboratoryGovernor.sol/LaboratoryGovernor.json'
```

:::tip Note

The `artifacts/` directory is included in the `.gitIgnore` and will need to be regenerated after cloning the repo or modifying the contracts. This can be done by running `yarn hh:com`.

:::

A `provider` & `signer` variable is needed to tell the contracts who the call is coming from `provider`, and verify the call is authorized `signer`.

Function calls that only *read* data from a contract require a `provider` and should cost (0) gas. 

Function calls that are *writing* to a contract are required to have a `signer`, as they must authorize the gas fee.

``` js title="provider & signer variables"
const provider = new ethers.providers.Web3Provider(window.ethereum)
const signer = provider.getSigner()
```

The `contract` object is then defined as such:

``` js title="contract object"
const contract = {
  lab: {
    read: new ethers.Contract(legendsLaboratory, LegendsLaboratory.abi, provider),
    write: new ethers.Contract(legendsLaboratory, LegendsLaboratory.abi, signer),
  },
  token: {
    read: new ethers.Contract(legendsToken, LegendToken.abi, provider),
    write: new ethers.Contract(legendsToken, LegendToken.abi, signer),
  },
  nft: {
    read: new ethers.Contract(legendsNFT, LegendsNFT.abi, provider),
    write: new ethers.Contract(legendsNFT, LegendsNFT.abi, signer),
  },
  rejuvenation: {
    read: new ethers.Contract(legendRejuvenation, LegendRejuvenation.abi, provider),
    write: new ethers.Contract(legendRejuvenation, LegendRejuvenation.abi, signer),
  },
  marketplace: {
    read: new ethers.Contract(legendsMarketplace, LegendsMarketplace.abi, provider),
    write: new ethers.Contract(legendsMarketplace, LegendsMarketplace.abi, signer),
  },
  matchingBoard: {
    read: new ethers.Contract(legendsMatchingBoard, LegendsMatchingBoard.abi, provider),
    write: new ethers.Contract(legendsMatchingBoard, LegendsMatchingBoard.abi, signer),
  },
  governor: {
    read: new ethers.Contract(laboratoryGovernor, LaboratoryGovernor.abi, provider),
    write: new ethers.Contract(laboratoryGovernor, LaboratoryGovernor.abi, signer),
  },
}
```



You are now ready to interact with the **Legendary Labs** contracts. As previously mentioned, the majority of calls are structured identically to one another. Simply swap out the contract-function name and include the correct parameters and you should be good to go.

All functions calling the smart contracts will need to be wrapped in an `if` statement verifying the client has a web3 wallet accessible.

``` js title="web3 wrapper"
async function callSmartContract() {
  if (typeof window.ethereum !== 'undefined') {
    // logic
  }
}
```

An additional variable will sometimes be needed if sending in an `address` parameter as `msg.sender`.

``` js title="account variable"
const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' })
```

``` js title="read from a contract"
async function fetchURI() {
  if (typeof window.ethereum !== 'undefined') {
    const legendURI = await contract.nft.read.fetchLegendURI(legendId)
  }
}
```

``` js title="write to a contract"
async function createPromoEvent() {
  if (typeof window.ethereum !== 'undefined') {
    await contract.lab.write.createPromoEvent(eventName, duration, isUnrestricted, maxTickets, skipIncubation)
  }
}
```


:::info Todo

## Develop API:

I plan to create an API for the front end to use, to further simplify the interactions between the smart contract and front end. Particularly for more complex functionalities we develop that chain multiple contract calls together.

:::

---

<br/>

## Glossary Of Terms
#### Terms throughout all Legendary Labs contracts and LabDocs
--- 
* *Auction* &rarr; A marketplace listing where multiple parties bid to purchase the NFT.
* *Blender* &rarr; The address that purchases the *match* listing. In marketplace terms, the buyer.
* *Blender Legend* &rarr; The Legend NFT the *blender* uses to *blend* with the *surrogate Legend*.
* *Blending* &rarr; The process where (2) Legend NFTs store their DNA information together to create a *child Legend*.
* *Blending Slots* &rarr; The **LegendsNFT** contract imposes a `_blendingLimit` on all Legend NFTs. This limit is the number of *blending slots* each legend has. If the `_blendingLimit` is set to `(5)` and a particular Legend has *blended* (3) times, they would of used up `3 of 5` *blending slots*. Once the limit is reached, a Legend can not *blend* again until after restoring some *blending slots*
* *Chain-Currency* &rarr; The currency used by the chain **Legendary Labs** is deployed on.
* *Child Legend* &rarr; A new Legend NFT that is created from two existing Legend NFTs *blending*.
* *Creator Address* &rarr; Any non-*zero address*, resposible for *blending* two Legends together. This address will recieve *royalties* every time their Legend NFT is sold on the [**LegendsMarketplace**](./marketplace/LegendsMarketplace). After the first initial sale, where the *creator address* is listing. 
* *Credit* &rarr; Due to using the *Pull over Push* pattern and an Escrow contract, *payments* from successful listings are credited to the appropriate address. The address will then withdraw what is owed to them directly from the Escrow, rather than being sent from `payer`.
* *Dispensed* &rarr; To increment the *promo ticket*-credit value assigned to the calling address, for a given *promo event*. 
* *DNA Generated URI* &rarr; The permanent URI assigned to a *child Legend* when it is *hatched* from its *incubator*.
* *Expired* &rarr; A *promo event* which can not longer dispense new tickets, but can still have existing tickets redeemed.
* *Hatched* &rarr; After a *child Legend* is fully formed it is ready to be removed from incubation.
* *Incubation* &rarr; The gestation phase *child Legends* undergo where their parents' DNA is unraveled and combines to form the new Legend's DNA.
* *Incubation URI* &rarr; The URI assigned to a *child Legend* composed of its parent Legends DNA. 
* *Instant Buy* &rarr; A set price for an *auction* to be closed at.
* *Legendary* &rarr; A Legend NFT with genetic data so rare, that there might only ever be one in existence.
* *Matching* &rarr; A marketplace listing type. Allows for *blending* between two Legend NFTs not owned by the same addres, for a price in LGND tokens.
* *Max Ticket Limit* &rarr; A set number of *promo tickets* that can be *dispensed* for a given *promo event*. *Promo events* that have not  yet *expired*, but have reached an assoiated *max ticket limit*, will no longer be able to dispense new *promo tickets*
* *Offer* &rarr; A marketplace listing where the prospective buyer initiates the listing, rather than the seller.
* *Promo Event* &rarr; An instance during which addresses can be credited with *promo tickets*.
* *Promo Ticket* &rarr; An integer credit assigned to an address, associated with a `promoId`. Used for granting access and functionality. Non-transferable asset.
* *Redeemed* &rarr; To decrement the *promo ticket*-credit value assigned to the calling address, for a given *promo event*. 
* *ReJu* &rarr; In-game unit of measurement used to calculate how much a Legend has *rejuvenated* while inside their *pod*.
* *Rejuvenation Pod* &rarr; Each Legend has their very own *rejuvenation pod* unique to that Legend. When a Legend is occupying their *rejuvenation pod* they can not be placed utilize any functionality that requires them to be in a *listable* state. However, while inside their *pod* a Legends earns *ReJu* to restore used *blending slots*.
* *Restricted Promo Event* &rarr; A *promo event* where only addresses assigned `LAB_TECH` access can dispense *promo tickets*.
* *Role* &rarr; A level of access granted to an address.
* *Role Admin* &rarr; A *role* with the authority to grant and revoke the *role* it is *role admin* of to addresses. 
* *Royalties* &rarr; *Chain-Currency* collected from successful marketplace listings, and *credited*
* *Sale* &rarr; The base listing type for a the **Legendary Labs Marketplace**, a traditional marketplace listing.
* *Securing* &rarr; In order to power some of **Legendary Labs** game functionalities, players will need to *secure* LGND tokens. These *secured* token are purely for in-game functionality, not financial. 
* *Standard Admin* &rarr; An address that can call `LAB_TECH` access-controlled functions .
* *Super Admin* &rarr; An address with the highest level of access that is allowed by the **Legendary Labs** contracts. Can call `LAB_ADMIN` access-controlled functions.
* *Surrogate* &rarr; The address responsible for creating the *match* listing. In marketplace terms, the seller.
* *Surrogate Legend* &rarr; The Legend NFT being listed in a *match* listing, belongs to the *surrogate*.
* *Unrestricted Promo Event* &rarr; A *promo event* where any address can dispense up to (1) *promo ticket*.
* *Zero Address* &rarr; `0x0000000000000000000000000000000000000000` **The Black Hole**, any Legend NFT or LGND tokens sent to this address can **NEVER** be retrieved.
